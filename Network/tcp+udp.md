# TCP & UDP

- 모두 IP 프로토콜을 기반으로 데이터를 보내기 위해 사용하는 프로토콜 

## TCP(Transmission Control Protocal)

연결 지향적 프로토콜로 연결 요청을 하고 이를 수락하면 고정된 통신 선로가 만들어져서 데이터를 정확하고 안정적으로 전달할 수 있다. 호스트간 신뢰성 있는 데이터 전달과 흐름제어를 한기 때문에 신뢰성이 보장되어야 하는 통신에서 많이 사용되는 방법

- 특징
  - 연결형 서비스로 가상 회선 방식으로 제공한다
    - 3-way handshaking과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제
    - 3-way handshaking 
      -  3번의 요청/응답 후에 연결이 되는 것
  - 흐름 제어 
    - 데이터 처리 속도를 조절해 수신자의 버퍼 오버플로우 방지
      - 송신하는 곳에서 감당이 안되게 많은 데이터를 빠르게 보내 수신하는 곳에서 문제가 일어나는 것을 막는다
  - 혼잡 제어
    - 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지
      - 정보의 소통량이 과다하면 패킷을 조그만 전송해 혼잡 붕괴 현상이 일어나는 것을 막는다.
  - 높은 신뢰성 보장
    - Dupack-based retransmission
      - 정상적인 상황에서는 ACK 값이 연속적으로 전송되어야 한다
      - ACK값이 중복적으로 올 경우 패킷 이상을 감지하고 재전송을 요청한다
    - Timeout-based retransmission
      - 일정시간동안 ACK 값이 수신을 못할 경우 재전송을 요청한다
  - 전이중(Full-Duplex)
    - 가상 회선으로 연결된 두 프로세스가 동시에 데이터를 전송할 수 있다.
  - 점대점(Point to Point) 방식
    - 각 연결이 정확히 2개의 종단점을 갖고 있다. 

응용 계층에서 데이터를 받으면 TCP는 헤더를 추가하고 이를 IP로 보낸다.

| 필드                         | 내용                                                         | 크기 |
| ---------------------------- | ------------------------------------------------------------ | ---- |
| 송수신자의 포트 번호         | TCP로 연결되는 가상 회선 양단의 송수신 프로세스에 할당되는 **포트 주소** | 16   |
| 시퀀스 번호(Sequence Number) | 송신자가 지정하는 순서 번호, **전송되는 바이트 수**를 기준으로 증가. SYN = 1 : 초기 시퀀스 번호가 된다. ACK 번호는 이 값에 1을 더한 값. SYN = 0 : 현재 세션의 이 세그먼트 데이터의 최초 바이트 값의 누적 시퀀스 번호 | 32   |
| 응답 번호(ACK Number)        | 수신 프로세스가 제대로 **수신한 바이트의 수**를 응답하기 위해 사용. | 32   |
| 데이터 오프셋(Data Offset)   | TCP 세그먼트의 시작 위치를 기준으로 **데이터의 시작 위치**를 표현(TCP 헤더의 크기) | 4    |
| 예약 필드(Reserved)          | 사용을 하지 않지만 나중을 위한 예약 필드이며 0으로 채워져야한다. | 6    |
| 제어 비트(Flag Bit)          | SYN, ACK, FIN 등의 제어 번호                                 | 6    |
| 윈도우 크기(Window)          | **수신 윈도우의 버퍼 크기**를 지정할 때 사용. 0이면 송신 프로세스의 전송 중지 | 16   |
| 체크섬(Checksum)             | TCP 세그먼트에 포함되는 프로토콜 헤더와 **데이터에 대한 오류 검출** 용도 | 16   |
| 긴급 위치(Urgent Pointer)    | 긴급 데이터를 처리하기 위함, URG 플래그 비트가 지정된 경우에만 유효 | 16   |

## TCP Connection

### 3-way handshake (연결 설정)

1. 클라이언트가 **SYN**을 보내고 **SYN_SENT** 상태로 대기한다
2. 서버는 응답을 받으면 **SYN_RCVD** 상태로 바꾸고 **SYN**과 **응답 ACK**를 보낸다
3. SYN과 응답 ACK을 받은 클라이언트는 **ESTABLISHED** 상태로 변경하고 서버에게 응답 **ACK**를 보낸다.
4. 응답 **ACK**를 받은 서버는 **ESTABLISHED** 상태로 변경한다

### 4-way handshake (연결 해제)

1. 클라이언트에서 **FIN**을 보내고 **FIN_WAIT1** 상태로 대기한다
2. 서버는 **CLOSE_WAIT**로 바꾸고 응답 ACK를 전달한다. 동시에 해당 포트에 연결되어 있는 응용에게 close()를 요청한다
3. ACK를 받은 클라이언트는 상태를 **FIN_WAIT2**로 변경한다
4. close() 요청을 받은 서버 어플리케이션은 종료 프로세스를 진행하고 **FIN**을 클라이언트에 보내 **LASK_ACK** 상태로 바꾼다
5. FIN을 받는 클라이언트는 ACK를 서버에 다시 전송하고 **TIME_WAIT**으로 상태를 바꾼다. **TIME_WAIT**에서 일정 시간이 지나면 **CLOSED** 된다. ACK를 받은 서버도 포트를  **CLOSED**로 닫는다.

---



## UDP

데이터의 형태 : Datagram(독립적인 관계를 지니는 패킷)

비연결 지향적 프로토콜로 데이터를 주고받을 때 연결 절차를 거치지 않고 일방적으로 데이터를 발신하는 방식. 연결하는 과정이 없기 때문에 TCP보다는 빠른 전송을 할 수 있지만 데이터 전달의 신뢰성은 떨어진다. 최악의 경우 데이터가 유실될 수 있는데 TCP와 다르게 UDP는 재전송을 하지 않는다. 주로 실시간으로 전송하거나 빠른 연결이 필요한 서비스들에 이용된다 (DNS, IPTV, 스트리밍, 게임)

* 특징
  * 확인응답 없음
    * 메시지가 제대로 도착했는지 확인하지 않음
  * 순서제어 없음
    * 수신된 메시지의 순서를 맞추지 않음
  * 흐름제어 없음
  * 오류제어 거의 없음
    * 검사합(무결성 확인)을 제외한 특별한 오류 검출 및 제어가 없다.
  * 비연결성
    * 논리적인 가상 회선 연결 필요 없음

  * 빠른 용청과 응답 및 멀티태스킹 가능
    * 1:N의 여러 다수 지점에 동시 전송 가능 (멀티캐스팅)

| 필드               | 내용                                                         | 크기 |
| ------------------ | ------------------------------------------------------------ | ---- |
| 송신자의 포트 번호 | 출발지의 포트 번호 표시                                      | 16   |
| 수신자의 포트 번호 | 목적지 포트 번호                                             | 16   |
| 길이               | 헤더와 데이터를 포함해 전체 UDP 메시지의 길이를 바아트 단위로 표시함 | 16   |
| 검사합             | 헤더와 데이터의 에러를 확인하고 검출하는 필드.  에러 복구를 위한 필드가 없기 때문에 TCP 헤더에 베해 간단한 구조 | 16   |


