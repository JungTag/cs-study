# 1. 교착 상태와 기아 상태

## 1-1. 교착 상태 (deadlock)
> 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다려 결국 아무것도 완료되지 못하는 상태

![](https://images.velog.io/images/sangmin7648/post/94fb3adf-0b6b-463e-a6a3-fb6ea4144d45/image.png)

- 위 사진처럼 앞의 차가 비켜야 지나갈 수 있지만, 서로가 서로를 막아 결국 아무도 지나갈 수 없는 경우를 교착 상태라고 할 수 있다.


## 1-2. 기아 상태 (starvation)
> 작업이 보다 우선 순위가 높은 작업에 의해 무기한 자원을 할당 받지 못하는 상태

- 식사하는 철학자 예시에서 특정 자리가 식사 우선권을 가지고 영원히 식사한다면 그 자리의 양쪽에 있는 철학자들은 무기한적으로 식사를 할 수 없다

<hr>

# 2. 교착 상태의 발생 조건과 해결

## 2-1. 발생 조건
> 어느 한 조건이라도 만족하지 못하면 교착 상태를 발생하지 않는다

1. 상호 배제 : 한 번에 한 프로세스만 해당 자원을 사용 가능
2. 점유 대기 : 할당된 자원을 가진 상태에서 다른 자원을 기다림
3. 비선점 : 다른 프로세스가 자원의 사용을 끝낼 때까지 자원을 뺏을 수 없음
4. 순환 대기 : 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있음

## 2-2. 해결 방법
> 교착 상태의 예방과 회피가 가장 근본적인 해결방법에 더 가까우나, 이를 달성하기 위해선 많은 자원이 사용된다. 따라서 현대의 시스템들은 교착 상태 발생 빈도에 따라 무시하거나 탐지 및 복구한다 

### 무시
- 교착 상태가 드물게 발생하는 시스템에서 일반적으로 사용한다, 리눅스/윈도우 같은 운영체제에서도 이를 사용한다 

- 기본적으로 교착 상태가 발생하지 않는다고 가정한다. 교착 상태가 일어나지 않을 것이므로 교착 상태 관리를 위해 자원을 사용하는 것은 낭비이다 

- 교착 상태가 발생한다면, 해결을 위해 프로세스를 종료해야하거나 시스템을 재부팅해야한다 

### 탐지 및 복구

- 교착 상태가 자주 발생하는 시스템에서 일반적으로 사용한다. 

- 탐지 및 복구 하에서, 교착 상태는 발생 가능하다. 알고리즘을 통해 자원 배분과 프로세스 과정을 관리하여, 교착 상태 발생 시 교착 상태에 연관된 프로세스와 자원을 탐지한다. 프로세스를 롤백하거나 재시작하는 것으로 해결한다.  

- 교착 상태 탐지 알고리즘의 실행 조건 또한 신경써야한다. 매일, 이틀에 한번 등 시간적으로 실행 할 수 있고, CPU 이용률 급감시 같은 조건으로 실행할 수도 있다.

### 회피

- 자원이 어떻게 요청될지 정보를 관리해 순환 대기가 발생하지 않도록 자원 할당 상태를 검사하고 관리한다.

- 대표적으로 은행원 알고리즘이 있다 

### 예방
- 발생 조건 중 하나를 만족하지 못하도록 한다 
1. 상호 배제 제거 : 공유 가능한 자원을 없애고 공유 불가능한 자원을 사용한다 

2. 점유 대기 제거 : 프로세스가 수행되기 전에 모든 필요 자원을 할당 시킨다

3. 비선점 제거 : 사용중인 자원을 뺏을 수 있는 프로토콜을 만든다

4. 순환 대기 제거 : 자원 유형에 따라 순서를 매긴다. 현재 점유한 자원보다 순서가 낮은/높은 자원을 대기하지 못하도록 한다

<hr>

# 3. LiveLock
- LiveLock은 교착 상태와 비슷하게 두개 이상의 프로세스가 서로 방해해 작업을 완료하지 못하는 상태이다

- 하지만 교착 상태와 달리 프로세스들이 무기한 대기 상태가 되는 것아니라, 각자 문제를 해결하고자 작동하는 것 때문에 서로 진행을 못하며 LiveLock 상태가 발생한다 

- 예를 들어 좁은 길에서 양쪽에서 오는 사람이 마주쳐 비켜 가야하는 상황이라고 하자. 한쪽으로 비켜가려고 하는데 반대편 사람도 같은 방향으로 비켰다면, 서로를 막아 지나갈 수 없다. 그래서 반대로 비켜가려고하는데 반대편 사람도 또 같이 움직였다면 또 다시 지나갈 수 없다. 이 과정이 계속 반복되면 LiveLock 상태이다. 

<hr>

# 4. 기아 상태의 발생 조건과 해결

## 4-1. 발생 조건

- 주로 스케쥴링이나 상호 배제 알고리즘의 오류로 발생하지만, 자원 누수나 DoS 공격등으로 발생할수도 있다. 

## 4-2. 해결 방법

- 스케쥴링 알고리즘의 오류로 인해 발생한 문제라면, 우선순위 선정 방식의 변경을 통해 최악의 경우에도 모든 프로세스에게 실행될 기회를 줘야한다 
