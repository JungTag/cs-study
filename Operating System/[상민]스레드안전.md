# CS스터디

## 스레드 안전(thread-safe)

스레드 안전은, 멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음을 뜻한다. 보다 엄밀하게는, 하나의 함수가 한 스레드에서 호출돼서 실행중일 때, 다른 스레드가 그 함수를 호출해서 동시에 함꼐 실행되더라도 각 스레드에서의 함수의 수행 결과가 올바로 나오는 것으로 정의한다. (출처: 위키백과)

예를 들어 아래와 같은 코드가 있다고 해 보자.

```py
a = 3
b = 2
print(a + b)
```

여러 스레드에서 이 코드를 동시에 실행했을 때 전부 다 같은 결과(5)가 나온다면, 그것이 바로 thread-safe 하다고 볼 수 있는 것이다. 하지만, 당연하게도 모든 코드가 thread-safe 하진 않다.

```ts
const isThreadSafe(d: object[], key: number, value: number) {
    d[key] += value
    d[key] = d[key] + value
    d[key] = d[key2]
}
```

이 코드는 thread-safe하다고 볼 수 없다. 왜냐하면, object를 조회하고 대입하는 과정에서 스레드 전환이 일어날 수 있기 때문이다.

### thread-safe의 여부를 판단하는 방법?

1. 전역 변수나 힙, 파일과 같이 여러 스레드가 동시에 접근할 수 있는 자원을 사용하는가?
2. 핸들과 포인터를 통한 데이터의 간접 접근이 가능한가?
3. 부수 효과를 가져오는 코드가 있는가?

이 세 가지를 통해 thread-safe한 상태인지의 여부를 확인할 수 있다.

### 스레드에 안전한 코드를 작성하는 방법

- Re-entrancy
  - 어떤 함수가 한 스레드에 의해 호출되어 실행중일 때, 다른 스레드가 그 함수를 호출하더라도 그 결과가 각각에게 올바로 주어져야 한다. 스레드끼리 독립적으로 동작할 수 있도록 코드를 짜라는 것으로 생각하면 될 것 같다.

- Thread-local storage
  - 공유 자원의 사용을 최대한 줄여 각각의 스레드에서만 접근 가능한 저장소들을 사용함으로써 동시 접근을 막는다. 전역 변수 사용을 자제하라는 뜻으로 생각하면 된다.

- Mutual exclusion
  - 만약 공유 자원(전역 변수 등)을 꼭 사용해야 될 경우에는, 해당 자원의 접근을 세마포어 등의 락으로 통제해야 한다.
    - 예를 들면, [Python에서의 threading.lock](https://velog.io/@kho5420/Python-Thread-and-Lock-%EC%93%B0%EB%A0%88%EB%93%9C%EC%99%80-%EB%9D%BD)이 있다. threading.lock을 acquire하면 해당 쓰레드만 공유 데이터에 접근할 수 있고, lock을 release해야만 다른 쓰레드에서 공유 데이터에 접근할 수 있다.

- Atomic operations
  - 공유 자원에 접근할 때 원자 연산을 이용하거나 원자적으로 정의된 접근 방법을 사용함으로써 상호 배제를 구현할 수 있다.
    - ex) `a += b`의 경우, 먼저 +연산을 한 뒤에 =연산을 하므로, 원자적이라고 보기 어렵다.

이러한, 크게 네 가지의 방법들 중에 thread-safe한 상황이 명백한 경우를 제외한다면 보통은 Mutual exclusion(동기화 객체)를 사용하는 것이 가장 일반적이다. 이것을 구현하는 것이 가장 쉽기 때문이다.

실생활에서 이 mutual exclusion을 사용하는 예시는, [GIL](https://ssungkang.tistory.com/entry/python-GIL-Global-interpreter-Lock%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C)이 있다. GIL이란 Global Interpreter Lock의 줄임말로, Python 인터프리터가 한 스레드만 하나의 바이트코드를 실행시킬 수 있도록 해주는 Lock을 의미한다. 즉 하나의 스레드에만 모든 자원을 허락하고 그 이후에는 락을 걸어 다른 스레드가 접근할 수 없게 만드는 것이다.

위키에서는, 이렇게 Python에서 GIL이 필요한 이유가, CPython의 메모리 관리 상태가 thread-safe하지 않기 때문이라고 하였다. 즉, 이러한 스레드 안전의 해결책으로서 사용하는 것이 GIL이라는 것이다.
