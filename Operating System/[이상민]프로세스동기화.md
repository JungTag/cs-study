# 프로세스 동기화
> 협력하는 프로세스 사이에서 실행 순서 규칙을 정하여 공유 자원의 일관성을 보장하는 것 

- 프로세스들의 경쟁 상태로 인해 공유 자원이 신뢰성을 잃는 것을 방지하기 위해, 규칙을 정하고 이를 따르게해 프로세스를 동기화한다

![](https://images.velog.io/images/sangmin7648/post/fcc56946-e0c7-44f1-8c8a-55df80276473/image.png)

## 1. 용어

- **경쟁 조건** : 여러 프로세스(또는 스레드)가 공유 자원에 동시에 접근할 때, 공유 자원에 대한 접근 순서에 따라 실행 결과가 달라질 수 있는 상황

- **임계 구역** : 여러 프로세스(또는 스레드)가 자원을 공유하는 상황에서, 하나의 프로세스(스레드)만 접근할 수 있도록 제한해둔 코드 영역 

## 2. 동기화와 관련된 고전적 문제들

1. 은행 계좌 문제
- 부모는 입금하고, 자식은 출금한다
- 입금과 출금 과정이 별도로 이뤄진다
- ** 임계 구역 : 계좌 잔액 변경**

2. 독자 저자 문제
- 독자는 책을 읽고, 저자는 책에 글을 추가한다
- 여러 독자가 동시에 글을 읽을 수 있지만, 동시에 저자는 글을 쓸 수 없다
- 저자가 글을 쓰고 있다면, 독자들은 글을 읽을 수 없고 다른 저자도 글을 쓸 수 없다 
- **임계 구역 : 책에 글 작성**

3. 생산자 소비자 문제
- 생산자는 창고에 물건을 넣고, 소비자는 창고에서 물건을 꺼낸다
- 창고가 가득 차면 물건을 넣을 수 없고, 비어 있으면 물건을 꺼낼 수 없다
- ** 임계 구역 : 창고를 확인하고 물건을 넣거나 빼기**

4. 식사하는 철학자 문제
- 원형 테이블에 철학자들이 앉아 있고 각 철학자의 양쪽엔 포크가 놓여있다
- 식사하기 위해서는 두개의 포크가 필요하다 
- 어떤 철학자가 식사를 하는 중이면, 양쪽에 있는 철학자는 식사할 수 없다
- **임계 구역 : 포크 사용 가능 여부 확인 후 사용**

## 3. 임계 구역 문제의 해결 조건
> 아래 3가지 조건을 모두 만족해야 해결할 수 있다

1. **상호 배제** : 한 프로세스가 임계구역에서 동작중이면 다른 프로세스는 접근할 수 없다.

2. **진행** : 임계구역에서 작업중인 프로세스가 없다면 입계구역으로 진입하려는 프로세스를 적절히 선택해서 진입하게 한다.

3. **유한 대기** : 다른 프로세스의 기아를 방지하기 위해, 임계 구역에 한 번 접근했던 프로세스는 다시 임계 구역에 들어갈 때 제한을 두어야 한다.

## 4. 임계 구역 문제의 소프트웨어적 해결 방안
> 이 글에 작성할 소프트웨어/하드웨어적 해결방안은 유한 대기 조건은 만족 시키지 못한다 

- 피터슨 알고리즘 : 2개 프로세스에 대한 임계 구역 문제 해결 알고리즘
- 데커 알고리즘 : 피터슨 알고리즘고 비슷한 2개 프로세스에 대한 임계 구역 문제 해결 알고리즘
- 램포트의 빵집 알고리즘 : 2개 이상의 프로세스에 사용가능한 임계 구역 문제 해결 알고리즘

```c
// 피터슨 알고리즘
// Shared data
int turn;
bool flag[2];

// Process i
do {
    flag[i] = true;  // 입장 구역, 자원 사용 요청
    turn = j;
    while (flag[j] && turn == j); // busy wait
    /* 임계 구역 */
    flag[i] = false;  // 퇴장 구역
    /* 나머지 구역 */
} while (true);

// Process j
do {
    flag[j] = true;  // 입장 구역, 자원 사용 요청
    turn = i;
    while (flag[i] && turn == i);  // busy wait
    /* 임계 구역 */
    flag[j] = false; // 퇴장 구역
    /* 나머지 구역 */
} while (true);

/* flag[j] && turn == j 의 뜻 */
// flag[j]이 true라면, 프로세스 j가 사용 요청을 하고 대기 중이거나 임계 구역에서 작업하고 있다는 뜻
// turn == j이 true라면, 프로세스 j가 아직 실행되지 않았거나 또는 프로세스 i보다 먼저 실행됐다는 뜻 
// flag[j] && turn == j가 true라면, 프로세스 j가 프로세스 i보다 먼져 임계 구역 접근을 요청했거나 프로세스 j가 임계 구역에서 작업 중이라는 뜻
```

## 5. 임계 구역 문제의 하드웨어적 해결 방안

- 락(lock)을 이용한 해결 방안: 프로세스가 락을 획득해야만 임계 구역에 진입할 수 있고, 임계 구역을 벗어나면 락을 반납하여, 임계 구역 문제를 해결.

- 임계구역 문제 해결을 위한 하드웨어 명령어로 test_and_set()과 swap()이 있다

```c
// test and set
bool test_and_set(bool *target) {
    bool ret = *target;
    *target = true; 
    return ret;
}
do {
    while (test_and_set(lock));
    /* 임계 구역 */
    lock = false;  // 퇴장 구역
    /* 나머지 구역 */
} while (true)
```

```c
// swap
void swap(bool *a, bool *b) {
    bool tmp = *a;
    *a = *b;
    *b = tmp;
}
do {
    key = true;
    while (key == true) swap(&lock, &key);
    /* 임계 구역 */
    lock = false;
    /* 나머지 구역 */
} while (true);
```

